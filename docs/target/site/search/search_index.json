{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"lagom-pb"},{"location":"/index.html#lagom-pb","text":"lagom-pb = lagom + Protocol Buffer\nScala shared code for lagom development using protocol buffer.\nThis library helps write lagom based microservices easily by making use of protocol buffer messages to define the es/cqrs core components like api requests/responses, grpc services, events, commands and state.\nGet Started Write Side Read Side Rest API gRPC Configuration Application loading","title":"lagom-pb"},{"location":"/get-started.html","text":"","title":"Get Started"},{"location":"/get-started.html#get-started","text":"Kindly check the latest version from Versions\nAdd to your plugins.sbt:\nval LagompbVersion = \"0.8.2\"\naddSbtPlugin(\"io.superflat\" % \"lagompb-plugin\" % LagompbVersion)\nAdd to your build.sbt:\nval LagompbVersion = \"0.8.2\"\nlibraryDependencies ++= Seq(\n  \"io.superflat\" %% \"lagompb-core\" % LagompbVersion,\n  \"io.superflat\" %% \"lagompb-core\" % LagompbVersion % \"protobuf\"\n)","title":"Get Started"},{"location":"/write-side.html","text":"","title":"Write Side"},{"location":"/write-side.html#write-side","text":"Write Side helps define the persistence entity/aggregate and how data come to the application by commands.\ncommands events state commands handler events handler aggregate root\nLet us now dive into the details of these components.\nTo be able to implement the write model the following dependency is required:\nsbt libraryDependencies += \"io.superflat\" %% \"lagompb-core\" % \"0.8.1\" Maven <dependency>\n  <groupId>io.superflat</groupId>\n  <artifactId>lagompb-core_2.13</artifactId>\n  <version>0.8.1</version>\n</dependency>","title":"Write Side"},{"location":"/write-side.html#commands","text":"Commands must be defined in protocol buffer messages. The commands can also be used as the api requests.\nExample:\nsyntax = \"proto3\";\n\npackage account;\n\nmessage OpenBankAccount {\n    string company_uuid = 1;\n    string account_id = 2;\n    double balance = 3;\n    string account_owner = 4;\n}","title":"Commands"},{"location":"/write-side.html#events","text":"Events as commands must be defined in protocol buffer messages.\nExample:\nsyntax = \"proto3\";\n\npackage account;\n\nmessage AccountOpened {\n    string company_uuid = 1;\n    string account_id = 2;\n    double balance = 3;\n    string account_owner = 4;\n}","title":"Events"},{"location":"/write-side.html#state","text":"Aggregate State must be defined in protocol buffer message. It is the result of events that have occurred on the entity/aggregate root. The state can be used as the api response when the request is successful.\nExample:\nsyntax = \"proto3\";\n\npackage account;\n\nmessage BankAccount {\n    string account_id = 1;\n    double account_balance = 2;\n    string account_owner = 3;\n    bool is_closed = 4;\n}","title":"State"},{"location":"/write-side.html#commands-handler","text":"Commands handler is the meat of the aggregate. They encode the business rules of your entity/aggregate and act as a guardian of the aggregate/entity consistency. Commands handler must first validate that the incoming command can be applied to the current model state. Lagom-pb makes at the developer disposal two abstract classes that can help implement a command handler:\nio.superflat.lagompb.CommandHandler io.superflat.lagompb.TypedCommandHandler[S] where S is the generated scala case class from the state proto definition. See state section\nWe strongly recommend the usage of the second abstract class.\nExample:\nclass AccountCommandHandler(actorSystem: ActorSystem) extends TypedCommandHandler[BankAccount](actorSystem) {\n\n  override def handleTyped(command: GeneratedMessage, currentState: BankAccount, currentMetaData: MetaData): Try[CommandHandlerResponse] = {\n    command match {\n      case o: OpenBankAccount => ???\n      case r: ReceiveMoney => ???\n      case t: TransferMoney => ???\n      case g: GetAccount => ???\n    }\n  }\n}","title":"Commands handler"},{"location":"/write-side.html#events-handler","text":"Event handlers mutate the state of the Aggregate by applying the events to it. Event handlers must be pure functions. This allows them to be tested without the need of the whole akka system. One can implement an events handler in lagom-pb by extending one of the following abstract classes:\nio.superflat.lagompb.EventHandler io.superflat.lagompb.TypedEventHandler[S] must be extended where S is the generated scala case class from the state proto definition.\nExample:\nclass AccountEventHandler(actorSystem: ActorSystem) extends TypedEventHandler[BankAccount](actorSystem) {\n\n  override def handleTyped(event: scalapb.GeneratedMessage, state: BankAccount, eventMeta: MetaData): BankAccount = {\n    event match {\n      case a: AccountOpened => ???\n      case m: MoneyReceived => ???\n      case t: MoneyTransferred => ???\n      case _ => ???\n    }\n  }\n}","title":"Events handler"},{"location":"/write-side.html#aggregate-root","text":"The aggregate root or model is defined in terms of Commands, Events, and State in the world of ES/CQRS and that has been the approach taken into lagom-pb. The aggregate root must extend the io.superflat.lagompb.AggregateRoot[S] where S is the generated scala case class from the state proto definition. See state section.\nThere are only four attributes to override:\nCommands handler. See commands handler section Events handler. See events handler section Initial state Aggregate name\nExample:\nfinal class AccountAggregate(\n                              actorSystem: ActorSystem,\n                              commandHandler: TypedCommandHandler[BankAccount],\n                              eventHandler: TypedEventHandler[BankAccount],\n                              encryptionAdapter: EncryptionAdapter\n) extends AggregateRoot[BankAccount](actorSystem, commandHandler, eventHandler, encryptionAdapter) {\n\n  override def aggregateName: String = \"Account\"\n\n  override def stateCompanion: GeneratedMessageCompanion[BankAccount] = BankAccount\n}","title":"Aggregate Root"},{"location":"/read-side.html","text":"","title":"Read Side"},{"location":"/read-side.html#read-side","text":"Read Side helps define how the events persisted by the Aggregate root are processed.\nTo be able to implement the readSide the following dependency is required:\nsbt libraryDependencies += \"io.superflat\" %% \"lagompb-readside\" % \"0.8.2\" Maven <dependency>\n  <groupId>io.superflat</groupId>\n  <artifactId>lagompb-readside_2.13</artifactId>\n  <version>0.8.2</version>\n</dependency>\nKindly check the latest version from Versions","title":"Read Side"},{"location":"/read-side.html#implementation","text":"The following classes can be extended to implement a read side processor.\nio.superflat.lagompb.readside.ReadSideProcessor io.superflat.lagompb.readside.TypedReadSideProcessor\nThe event and the resulting state is made available for processing. The read offsets are stored in postgres database.\nio.superflat.lagompb.readside.KafkaPublisher This is used to send the event, and the resulting state into kafka as serialized protocol buffer message. The following protocol buffer messages are used to persist the messages to kafka:\nsyntax = \"proto3\";\n\npackage lagompb;\n\noption java_package = \"io.superflat.lagompb.protobuf\";\n\nimport \"google/protobuf/any.proto\";\n\nmessage KafkaEvent {\n    // the service name\n    string service_name = 1;\n    // the kafka partition key\n    string partition_key = 2;\n    // the actual event\n    google.protobuf.Any event = 3;\n    // the actual state with state meta\n    StateWrapper state = 4;\n}\n\nmessage StateWrapper {\n    // the entity state\n    google.protobuf.Any state = 1;\n    // metadata from the event that made this state\n    MetaData meta = 2;\n}\nNote Any protocol buffer message deserializer can be used to unmarshal the byte array persisted into kafka topic. Lagom-pb via the akka projection maintain read offsets in postgres database. Many instances of these abstract classes can be instantiated depending upon the business rules.","title":"Implementation"},{"location":"/rest-api.html","text":"","title":"Rest API"},{"location":"/rest-api.html#rest-api","text":"The REST API is an interface that helps interact with both the Write Side and the Read Side using HTTP-Json.\nApi service definition Api service implementation\nBefore one can define his/her api service he/she must define the various protocol messages that describe the REST service to be implemented.","title":"Rest API"},{"location":"/rest-api.html#api-service-definition","text":"Lagom-pb offers an interface that helps define the lagom api service which is : io.superflat.lagompb.BaseService.\nThe api service definition must be a scala trait.\nExample:\npackage io.superflat.lagompb.samples.account.api\n\nimport akka.NotUsed\nimport com.lightbend.lagom.scaladsl.api.{Descriptor, ServiceCall}\nimport com.lightbend.lagom.scaladsl.api.Service.restCall\nimport com.lightbend.lagom.scaladsl.api.transport.Method\nimport io.superflat.lagompb.samples.protobuf.account.apis.{\n  ApiResponse,\n  OpenAccountRequest,\n  ReceiveMoneyRequest,\n  TransferMoneyRequest\n}\nimport io.superflat.lagompb.BaseService\n\ntrait AccountService extends BaseService {\n\n  def openAccount: ServiceCall[OpenAccountRequest, ApiResponse]\n  def transferMoney(accountId: String): ServiceCall[TransferMoneyRequest, ApiResponse]\n  def receiveMoney(accountId: String): ServiceCall[ReceiveMoneyRequest, ApiResponse]\n  def getAccount(accountId: String): ServiceCall[NotUsed, ApiResponse]\n\n  override val routes: Seq[Descriptor.Call[_, _]] = Seq(\n    restCall(Method.POST, \"/api/accounts\", openAccount _),\n    restCall(Method.PATCH, \"/api/accounts/:accountId/transfer\", transferMoney _),\n    restCall(Method.PATCH, \"/api/accounts/:accountId/receive\", receiveMoney _),\n    restCall(Method.GET, \"/api/accounts/:accountId\", getAccount _)\n  )\n}\nNote: The api service definition must be done in a separate sbt module(recommended way). So a lagom-pb/lagom service requires at least two sbt modules in an sdbt multi-modules project.","title":"Api Service Definition"},{"location":"/rest-api.html#api-service-implementation","text":"Once the api service is defined, we can implement the api service by extending the io.superflat.lagompb.BaseServiceImpl mixed in with the api definition trait See api definition section.","title":"Api Service implementation"},{"location":"/grpc.html","text":"","title":"gRPC"},{"location":"/grpc.html#grpc","text":"The gRPC is an interface that helps interact with both the Write Side and the Read Side using gRPC service calls.\nTo implement a grpc service you must:\nAdd the following settings to your build.sbt of your sbt module\n......\n  .settings(\n    inConfig(Compile)(\n      Seq(\n        PB.protoSources := Seq(file(<path-to-your-proto-definitions>)),\n        PB.includePaths ++= Seq(file(<path-to-your-include>)),\n      )\n    ),\n    // Using Scala\n    akkaGrpcGeneratedLanguages := Seq(AkkaGrpc.Scala),\n    akkaGrpcExtraGenerators in Compile += PlayScalaServerCodeGenerator,\n    akkaGrpcExtraGenerators in Compile += PlayScalaClientCodeGenerator,\n    akkaGrpcCodeGeneratorSettings += \"server_power_apis\",\n    akkaGrpcCodeGeneratorSettings := akkaGrpcCodeGeneratorSettings.value.filterNot(\n      _ == \"flat_package\"\n    )\n  )\nFrom the root folder of your project run sbt clean compile to generate the grpc scala traits. Implement the generated traits by injecting the following akka.cluster.sharding.typed.scaladsl.ClusterSharding and com.lightbend.lagom.scaladsl.persistence.PersistentEntityRegistry and mixed in with io.superflat.lagompb.BaseGrpcServiceImpl to be able to interact with the domain model implementation.","title":"gRPC"},{"location":"/configuration.html","text":"","title":"Configuration"},{"location":"/configuration.html#configuration","text":"Every lagom-pb based application must include the lagompb.conf into the application.conf.\nKindly check the lagompb.conf file to see the various environment variables and configuration settings that can be overridden in the application.conf.\nFor the readSide implementation kindly check the reference.conf of lagompb-readside package to see the various environment variables and configuration settings that can be overridden in the application.conf.","title":"Configuration"},{"location":"/application-loader.html","text":"","title":"Application loading"},{"location":"/application-loader.html#application-loading","text":"The application loader defines how your lagom-pb/lagom based application should start. Two loading are available:\nthe development mode (for local development) the production mode\nTo define the application loader, we must first define the application by extending the io.superflat.lagompb.BaseApplication. Once the application is implemented then we can define the application loader by extending the com.lightbend.lagom.scaladsl.server.LagomApplicationLoader.\nExample:\npackage io.superflat.lagompb.samples.account\n\nimport com.lightbend.lagom.scaladsl.akka.discovery.AkkaDiscoveryComponents\nimport com.lightbend.lagom.scaladsl.api.Descriptor\nimport com.lightbend.lagom.scaladsl.devmode.LagomDevModeComponents\nimport com.lightbend.lagom.scaladsl.server.{\n  LagomApplication,\n  LagomApplicationContext,\n  LagomApplicationLoader,\n  LagomServer\n}\nimport com.softwaremill.macwire.wire\nimport io.superflat.lagompb.{AggregateRoot, BaseApplication, CommandHandler, EventHandler}\nimport io.superflat.lagompb.encryption.{NoEncryption, ProtoEncryption}\nimport io.superflat.lagompb.samples.account.api.AccountService\nimport io.superflat.lagompb.samples.protobuf.account.state.BankAccount\n\nabstract class AccountApplication(context: LagomApplicationContext) extends BaseApplication(context) {\n  // Let us hook in the readSide Processor\n  lazy val accountRepository: AccountRepository =\n    wire[AccountRepository]\n\n  // wire up the various event and command handler\n  lazy val eventHandler: TypedEventHandler[BankAccount] = wire[AccountEventHandler]\n  lazy val commandHandler: TypedCommandHandler[BankAccount] = wire[AccountCommandHandler]\n  lazy val aggregate: AggregateRoot[BankAccount] = wire[AccountAggregate]\n  lazy val encryptor: ProtoEncryption = NoEncryption\n\n  override def aggregateRoot: AggregateRoot[_] = aggregate\n\n  override def server: LagomServer =\n    serverFor[AccountService](wire[AccountServiceImpl])\n      .additionalRouter(wire[AccountGrpcServiceImpl])\n\n  lazy val accountReadProcessor: AccountReadProcessor = wire[AccountReadProcessor]\n  lazy val kafkaPublisher: AccountKafkaPublisher = wire[AccountKafkaPublisher]\n\n  accountReadProcessor.init()\n  kafkaPublisher.init()\n}\n\nclass AccountApplicationLoader extends LagomApplicationLoader {\n  override def load(context: LagomApplicationContext): LagomApplication =\n    new AccountApplication(context) with AkkaDiscoveryComponents\n\n  override def loadDevMode(context: LagomApplicationContext): LagomApplication =\n    new AccountApplication(context) with LagomDevModeComponents\n\n  override def describeService: Option[Descriptor] = Some(readDescriptor[AccountService])\n}\nOnce you define the application make sure to add it to the application.conf as play.application.loader=<your-loader>\nExample:\ninclude \"lagompb.conf\"\nplay {\n\tapplication {\n\t\tloader = io.superflat.lagompb.samples.account.AccountApplicationLoader\n\t}\n}","title":"Application loading"}]}